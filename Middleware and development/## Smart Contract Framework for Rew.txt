// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract RewardBurnWallet is ERC20, Ownable, VRFConsumerBase {
    // Constants
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 10 ** 18;
    uint256 public constant MIN_BALANCE = 1_000 * 10 ** 18;
    uint256 public constant REWARD_PERCENTAGE = 1; // 1%
    uint256 public constant MAX_ELIGIBLE_WALLETS = 1000;

    // State Variables
    uint256 public rewardWalletBalance;
    uint256 public lastActionTimestamp;
    bool public isRewardDay = true; // Alternates daily

    mapping(address => uint256) public cooldownEnd;
    mapping(address => bool) public excludedWallets;

    address[] public eligibleWallets;
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;

    event RewardDistributed(uint256 totalReward, address[] wallets);
    event TokensBurned(uint256 amount);
    event CooldownUpdated(address wallet, uint256 cooldownEnd);

    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        uint256 _fee
    ) ERC20("1000 Token", "1000") VRFConsumerBase(_vrfCoordinator, _linkToken) {
        keyHash = _keyHash;
        fee = _fee;
        rewardWalletBalance = TOTAL_SUPPLY / 5; // 20% allocated for reward/burn wallet
        _mint(msg.sender, TOTAL_SUPPLY - rewardWalletBalance); // Initial circulating supply
    }

    // Modifier to ensure eligible wallets
    modifier onlyEligibleWallets(address wallet) {
        require(balanceOf(wallet) >= MIN_BALANCE, "Insufficient balance to be eligible");
        require(block.timestamp > cooldownEnd[wallet], "Wallet is in cooldown period");
        require(!excludedWallets[wallet], "Wallet is excluded");
        _;
    }

    // Add or remove wallets from exclusion list
    function setExcludedWallet(address wallet, bool status) external onlyOwner {
        excludedWallets[wallet] = status;
    }

    // Reward Distribution
    function distributeRewards() external onlyOwner {
        require(isRewardDay, "Today is not a reward day");
        require(rewardWalletBalance > 0, "Reward wallet is empty");

        uint256 rewardAmount = (rewardWalletBalance * REWARD_PERCENTAGE) / 100;
        rewardWalletBalance -= rewardAmount;

        // Ensure eligible wallets have been set
        require(eligibleWallets.length > 0, "No eligible wallets available");
        requestRandomness(keyHash, fee);
    }

    // Burn Tokens
    function burnTokens() external onlyOwner {
        require(!isRewardDay, "Today is not a burn day");
        require(rewardWalletBalance > 0, "Reward wallet is empty");

        uint256 burnAmount = (rewardWalletBalance * REWARD_PERCENTAGE) / 100;
        rewardWalletBalance -= burnAmount;
        _burn(address(this), burnAmount);

        emit TokensBurned(burnAmount);
    }

    // Chainlink VRF Callback for Randomness
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
        uint256 totalReward = (rewardWalletBalance * REWARD_PERCENTAGE) / 100;
        uint256 rewardPerWallet = totalReward / eligibleWallets.length;

        for (uint256 i = 0; i < eligibleWallets.length && i < MAX_ELIGIBLE_WALLETS; i++) {
            address wallet = eligibleWallets[(randomness + i) % eligibleWallets.length];
            _transfer(address(this), wallet, rewardPerWallet);
        }

        emit RewardDistributed(totalReward, eligibleWallets);
    }

    // Cooldown Logic
    function updateCooldown(address wallet, uint256 percentageSold) internal {
        uint256 cooldownDuration;

        if (percentageSold < 10) {
            cooldownDuration = 3 days;
        } else if (percentageSold < 25) {
            cooldownDuration = 7 days;
        } else if (percentageSold < 50) {
            cooldownDuration = 14 days;
        } else {
            cooldownDuration = 30 days;
        }

        cooldownEnd[wallet] = block.timestamp + cooldownDuration;
        emit CooldownUpdated(wallet, cooldownEnd[wallet]);
    }

    // Simulate Daily Toggle
    function toggleDay() external onlyOwner {
        isRewardDay = !isRewardDay;
    }

    // Fetch Eligible Wallets (Off-Chain Integration Required)
    function setEligibleWallets(address[] memory wallets) external onlyOwner {
        eligibleWallets = wallets;
    }
}

